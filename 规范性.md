## 抽象类不应该有公共的构造函数

["abstract" classes should not have "public" constructors]

由于abstract类无法实例化，因此它们的拥有public或internal 构造函数毫无意义。如果在创建扩展类实例时存在基本的初始化逻辑，则可以将其放在构造函数中，但可以将其构造为private或protected。

不建议的：

``` C#
abstract class Base
{
    public Base() // Noncompliant, should be private or protected
    {
      //...
    }
}

```

建议的：

```
abstract class Base
{
    protected Base()
    {
      //...
    }
}
```

## 建议使用Any() 判断集合是否为空

["Any()" should be used to test for emptiness]

使用.Count()可以测试是否为空，但是使用.Any()意图更清晰，代码更易读。但是，在某些情况下应特别注意：

-如果集合是EntityFrameworkORM查询或其他ORM查询，则调用.Count()将导致执行潜在的大规模SQL查询，并可能在应用程序数据库上造成大量开销。调用.Any()将生成效率更高的SQL。

-如果集合是包含.Select()创建对象的语句的LINQ查询的一部分，则可能会不必要地分配大量内存。调用.Any()将更加有效，因为它将执行较少的可枚举迭代。


不建议的：

``` C#
private static bool HasContent(IEnumerable<string> strings)
{
  return strings.Count() > 0;  // Noncompliant
}

private static bool HasContent2(IEnumerable<string> strings)
{
  return strings.Count() >= 1;  // Noncompliant
}

private static bool IsEmpty(IEnumerable<string> strings)
{
  return strings.Count() == 0;  // Noncompliant
}

```

建议的：

``` C#
private static bool HasContent(IEnumerable<string> strings)
{
  return strings.Any();
}

private static bool IsEmpty(IEnumerable<string> strings)
{
  return !strings.Any();
}
```

## 不建议使用Assembly.GetExecutingAssembly()

Type.Assembly就性能而言，使用当前组件几乎是可以忽略不计的，这是一个简单的属性访问，但是Assembly.GetExecutingAssembly()可能要花费多达30倍的时间，因为它要沿着调用堆栈查找程序集。

请注意，Assembly.GetExecutingAssembly()是返回包含当前执行的应用程序的启动对象的程序集。例如，如果从应用程序执行，它将返回应用程序程序集，但是，如果从单元测试项目执行，则可能返回单元测试程序集。Type.Assembly始终返回包含指定类型的程序集。

不建议的：

``` C#
public class Example
{
   public static void Main()
   {
      Assembly assem = Assembly.GetExecutingAssembly(); // Noncompliant
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}

```

建议的：

``` C#
public class Example
{
   public static void Main()
   {
      Assembly assem = typeof(Example).Assembly; // Here we use the type of the current class
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
```

## “atch”子句的作用不仅仅在于重新抛出异常

["catch" clauses should do more than rethrow]

不建议的：

``` C#
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e)  // Noncompliant
{
  throw;
}

```

建议的：

``` C#
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e) // Compliant
{
  logger.LogError(e);
  throw;
}
```

## "default"子句应位于第一个或最后一个


不建议的：

``` C#
switch (param)
{
    case 0:
      DoSomething();
      break;
    default: // default clause should be the first or last one
      Error();
      break;
    case 1:
      DoSomethingElse();
      break;
}

```

建议的：

``` C#
switch (param)
{
    case 0:
      DoSomething();
      break;
    case 1:
      DoSomethingElse();
      break;
    default:
      Error();
      break;
}
```

## 实现“ IComparable”时，应覆盖“Equals”和比较运算符

当你实现IComparable或IComparable<T>一类，你也应该重写Equals(object) 和重载比较运算符（==，!=，<，<=，>， >=）。此外，最佳做法是GetHashCode()与Equals()一起重写。

不建议的：

``` C#
public class Foo: IComparable  // Noncompliant
{
  public int CompareTo(object obj) { /* ... */ }
}

```

建议的：

``` C#
public class Foo: IComparable
{
  public int CompareTo(object obj) { /* ... */ }
  public override bool Equals(object obj)
  {
    var other = obj as Foo;
    if (object.ReferenceEquals(other, null))
    {
      return false;
    }
    return this.CompareTo(other) == 0;
  }
  public int GetHashCode() { /* ... */ }
  public static bool operator == (Foo left, Foo right)
  {
    if (object.ReferenceEquals(left, null))
    {
      return object.ReferenceEquals(right, null);
    }
    return left.Equals(right);
  }
  public static bool operator > (Foo left, Foo right)
  {
    return Compare(left, right) > 0;
  }
  public static bool operator < (Foo left, Foo right)
  {
    return Compare(left, right) < 0;
  }
  public static bool operator != (Foo left, Foo right)
  {
    return !(left == right);
  }
}
```

## 空语句应该删除

不建议的：

``` C#
void DoSomething()
{
    ; // Noncompliant - was used as a kind of TODO marker
}

void DoSomethingElse()
{
    Console.WriteLine("Hello, world!");;  // Noncompliant - double ;
    // ...
    // Rarely, they are used on purpose as the body of a loop. It is a bad practice to
    // have side-effects outside of the loop:
    for (int i = 0; i < 3; Console.WriteLine(i), i++); // Noncompliant
    // ...
}

```

建议的：

``` C#
void DoSomething()
{
}

void DoSomethingElse()
{
    Console.WriteLine("Hello, world!");
    // ...
    for (int i = 0; i < 3; i++)
    {
        Console.WriteLine(i);
     }
    // ...
}

```

## 枚举成员不应命名为“reserved”

如果enum成员名称中包含“reserved”一词，则表示该成员当前未使用，将来会更改。无需保留enum成员，因为将来可以添加新成员，并且这种添加通常不会带来重大变化。

不建议的：

``` C#
using System;

namespace MyLibrary
{
  public enum Color
  {
        None,
        Red,
        Orange,
        Yellow,
        ReservedColor  // Noncompliant
    }
}
```

## “for”循环增量子句应修改循环的计数器

["for" loop increment clauses should modify the loops' counters]

当for循环的计数器未在其递增子句递增时，可能会造成不可预知的问题。在这种情况下，应将增量移到循环的增量子句中。

不建议的：

``` C#
for (i = 0; i < 10; j++) // Noncompliant
{
  // ...
}
```

建议的：

``` C#
for (i = 0; i < 10; i++)
{
  // ...
}
```

## for循环停止条件应不变

["for" loop stop conditions should be invariant]

在for循环里的循环停止条件应该尽量使用一个不变的值（即在开始和每次循环的结束都一样）。理想情况下，这意味着将在循环开始之前将停止条件设置为局部变量。

可变的停止条件效率稍低，并且难以理解和维护，并且有可能导致将来引入错误。

此规则跟踪三种类型的非停止条件：

当循环计数器在for循环体内被更新
当停止条件取决于方法调用时
当停止条件取决于对象属性时，由于这些属性在循环执行期间可能会更改。

不建议的：

``` C#
class Foo
{
    static void Main()
    {
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine(i);
            if (condition)
            {
               i = 20;
           }
        }
    }
}

```

建议的：

``` C#
class Foo
{
    static void Main()
    {
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine(i);
        }
    }
}
```

## 不建议使用 GC.Collect

["GC.Collect" should not be called]

调用GC.Collect几乎是没有必要的，并且会严重影响应用程序的性能。那是因为它触发了一个阻塞操作，该操作检查内存中的每个对象以进行清理。此外，您无法控制此阻止清除何时真正运行。

通常，调用此方法的后果远大于好处，除非您可能刚刚触发了程序运行中唯一的事件，该事件导致许多长生命周期的对象销毁。

不建议的：

``` C#
static void Main(string[] args)
{
  // ...
  GC.Collect(2, GCCollectionMode.Optimized); // Noncompliant
}

```

## GC.SuppressFinalize 不建议单独调用

"GC.SuppressFinalize" should not be called

GC.SuppressFinalize请求系统不为指定对象调用回收器。仅作为析构函数的一部分进行实现时，才应这样做。

## Generic.List实例不应成为公共API的一部分

"Generic.List" instances should not be part of public APIs

System.Collections.Generic.List<T>是为性能而不是继承而设计的通用集合。例如，它不包含使更容易更改继承的类的行为的虚拟成员。这意味着将来扩展行为的尝试将被破坏，因为扩展点根本不存在。而是，应使用以下通用集合之一：

System.Collections.Generic.IEnumerable<T>
System.Collections.Generic.IReadOnlyCollection<T>
System.Collections.Generic.ICollection<TKey>
System.Collections.Generic.IReadOnlyList<T>
System.Collections.Generic.IList<TKey>
System.Collections.ObjectModel.Collection<T>
System.Collections.ObjectModel.ReadOnlyCollection<T>
System.Collections.ObjectModel.KeyedCollection<TKey, Titem>


不建议的：

```C#
namespace Foo
{
   public class Bar
   {
      public List<T> Method1(T arg) // Noncompliant
      {
           //...
      }
   }
}

```

建议的：

``` C#
namespace Foo
{
   public class Bar
   {
      public Collection<T> Method1(T arg)
      {
           //...
      }
   }
}
```

## 不建议使用goto语句

## 正确实现 IDisposable

"IDisposable" should be implemented correctly

实现IDisposable接口是用来释放非托管资源，如果实现不正确，可能会导致资源泄漏或更严重的错误。

如果不遵守Microsoft定义的推荐处置方式，则此规则会引起问题。有关示例，请参见官方文档Compliant Solution部分。

## if ... else if 应以 else 子句结尾

"if ... else if" constructs should end with "else" clauses

只要一条if语句后跟一个或多个else if语句，则适用此规则。最后else if 应附有else声明。

不建议的：

``` C#
if (x == 0)
{
    DoSomething();
}
else if (x == 1)
{
    DoSomethingElse();
}

```

建议的：

``` C#
if (x == 0)
{
    DoSomething();
}
else if (x == 1)
{
    DoSomethingElse();
}
else
{
    throw new InvalidOperationException();
}
```

## IndexOf检查不应该包含正数

"IndexOf" checks should not be for positive numbers

大多数针对一个IndexOf值的检查会将其与-1进行比较，因为0是有效索引。任何寻找值的检查都会>0忽略第一个元素，这很可能是一个错误。如果意图是仅仅检查在包含一个值的string， List或者一个数组，可以考虑使用Contains的方法来代替。

不建议的：

``` C#
string color = "blue";
string name = "ishmael";

List<string> strings = new List<string>();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) > 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ish") > 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ae") > 0) // Noncompliant
{
  // ...
}
if (Array.IndexOf(stringArray, color) > 0) // Noncompliant
{
  // ...
}

```

建议的：

``` C#
List<string> strings = new List<string> ();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) > -1)
{
  // ...
}
if (name.IndexOf("ish") >= 0)
{
  // ...
}
if (name.Contains("ae"))
{
  // ...
}
if (Array.IndexOf(stringArray, color) >= 0)
{
  // ...
}
```

## “接口”实例不应转换为具体类型

需要从interface转换为具体类型表示抽象有问题，可能是缺少了interface。代替强制转换为具体类型，应将缺少的方法添加到中 interface。否则存在运行时异常的风险。

不建议的：

``` C#
public interface IMyInterface
{
  void DoStuff();
}

public class MyClass1 : IMyInterface
{
  public int Data { get { return new Random().Next(); } }

  public void DoStuff()
  {
    // TODO...
  }
}

public static class DowncastExampleProgram
{
  static void EntryPoint(IMyInterface interfaceRef)
  {
    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant
    int privateData = class1.Data;

    class1 = interfaceRef as MyClass1;  // Noncompliant
    if (class1 != null)
    {
      // ...
    }
  }
}

```

## is 不建议和 this 一起使用

this和is没有一起使用的情况，这种用法唯一合理解释是，您将根据子类的类型有条件地在父类中执行代码this。但是，特定于子类的代码应 位于该子类中，而不是父类中。

``` C#
public class JunkFood
{
  public void DoSomething()
  {
    if (this is Pizza) // Noncompliant
    {
      // ...
    } else if (...
  }
}

``` 

## 不应该使用new Guid()

当使用new Guid()（即无参数实例化）时，一定以下三项需要之一：

1. 空的GUID，在这种情况下Guid.Empty更清晰。
2. 随机生成的GUID，应使用Guid.NewGuid()。
3. 具有特定初始化的新GUID，缺少初始化参数。

不建议的：

``` C#

public void Foo()
{
    var g = new Guid(); // Noncompliant - what's the intent?
}
```

建议的：

``` C#
public void Foo(byte[] bytes)
{
    var g1 = Guid.Empty;
    var g2 = Guid.NewGuid();
    var g3 = new Guid(bytes);
}
```

## 属性Obsolete应该包含说明文字

"Obsolete" attributes should include explanations

## 引用类型不建议重载运算符 operator== 

"operator==" should not be overloaded on reference types

## out 和 ref 参数不建议同事使用

"out" and "ref" parameters should not be used

## P/Invoke 方法不建议公开访问

"P/Invoke" methods should not be visible

带有System.Runtime.InteropServices.DllImportAttribute属性标记的方法使用Platform Invocation Services访问非托管代码，因此不应公开。将它们保持为私有或内部状态可确保对其访问进行控制和正确管理。


不建议的：

``` C#
namespace MyLibrary
{
    public class Foo
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        public static extern bool RemoveDirectory(string name);  // Noncompliant
    }
}
```

建议的：

``` C#
using System;
using System.Runtime.InteropServices;

namespace MyLibrary
{
    public class Foo
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern bool RemoveDirectory(string name);
    }
}
```

## 建议用 params 代替 varargs 的使用 

"params" should be used instead of "varargs"


不建议的：

``` C#
using System;

namespace MyLibrary
{
    public class Foo
    {
        public void Bar(__arglist) // Noncompliant
        {
            ArgIterator argumentIterator = new ArgIterator(__arglist);
            for(int i = 0; i < argumentIterator.GetRemainingCount(); i++)
            {
                Console.WriteLine(
                    __refvalue(argumentIterator.GetNextArg(), string));
            }
        }
    }
}

```

建议的：

``` C#
using System;

[assembly: CLSCompliant(true)]
namespace MyLibrary
{
    public class Foo
    {
        public void Bar(params string[] wordList)
        {
            for(int i = 0; i < wordList.Length; i++)
            {
                Console.WriteLine(wordList[i]);
            }
        }
    }
}
```

--------------------------------------------------------------------------------------
## 



不建议的：

``` C#


```

建议的：

``` C#

```
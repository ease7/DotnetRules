# 严重问题

## 1.“[DefaultValue]”不应该在表示“[DefaultParameterValue]”时使用

不规范的例子：

```C#
class MyClass
{
    public void DoStuff([Optional][DefaultValue(4)]int i, int j = 5)  // Noncompliant
    {
        Console.WriteLine(i);
    }

    public static void Main()
    {
        new MyClass().DoStuff(); // prints 0
    }
}
```

规范的例子：

```C#
class MyClass
{
    public void DoStuff([Optional][DefaultParameterValue(4)]int i, int j = 5)
    {
        Console.WriteLine(i);
    }

    public static void Main()
    {
        new MyClass().DoStuff(); // prints 4
    }
}
```

## 2."[Optional]" should not be used on "ref" or "out" parameters

## 3."ConfigureAwait(false)" should be used

## 4."default"子句应位于第一个或最后一个

不规范的例子：

```C#
switch (param)
{
    case 0:
      DoSomething();
      break;
    default: // default clause should be the first or last one
      Error();
      break;
    case 1:
      DoSomethingElse();
      break;
}

```

规范的例子：

```C#
switch (param)
{
    case 0:
      DoSomething();
      break;
    case 1:
      DoSomethingElse();
      break;
    default:
      Error();
      break;
}
```



## 5. 不应该使用“foreach”循环的“显式”转换

## 6.for 循环增量子句应修改循环的计数器

["for" loop increment clauses should modify the loops' counters]

当 for 循环的计数器未在其递增子句递增时，可能会造成不可预知的问题。在这种情况下，应将增量移到循环的增量子句中。

不规范的例子：

```C#
for (i = 0; i < 10; j++) // Noncompliant
{
  // ...
}
```

规范的例子：

```C#
for (i = 0; i < 10; i++)
{
  // ...
}
```

## 7.不建议使用 GC.Collect

["GC.Collect" should not be called]

调用 GC.Collect 几乎是没有必要的，并且会严重影响应用程序的性能。那是因为它触发了一个阻塞操作，该操作检查内存中的每个对象以进行清理。此外，您无法控制此阻止清除何时真正运行。

通常，调用此方法的后果远大于好处，除非您可能刚刚触发了程序运行中唯一的事件，该事件导致许多长生命周期的对象销毁。

不规范的例子：

```C#
static void Main(string[] args)
{
  // ...
  GC.Collect(2, GCCollectionMode.Optimized); // Noncompliant
}

```

## 8.if ... else if 应以 else 子句结尾

"if ... else if" constructs should end with "else" clauses

只要一条 if 语句后跟一个或多个 else if 语句，则适用此规则。最后 else if 应附有 else 声明。

不规范的例子：

```C#
if (x == 0)
{
    DoSomething();
}
else if (x == 1)
{
    DoSomethingElse();
}

```

规范的例子：

```C#
if (x == 0)
{
    DoSomething();
}
else if (x == 1)
{
    DoSomethingElse();
}
else
{
    throw new InvalidOperationException();
}
```

## 9.IndexOf 判断不应该包含正数

"IndexOf" checks should not be for positive numbers

大多数针对一个 IndexOf 值的检查会将其与-1 进行比较，因为 0 是有效索引。任何寻找值的检查都会>0 忽略第一个元素，这很可能是一个错误。如果意图是仅仅检查在包含一个值的 string， List 或者一个数组，可以考虑使用 Contains 的方法来代替。

不规范的例子：

```C#
string color = "blue";
string name = "ishmael";

List<string> strings = new List<string>();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) > 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ish") > 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ae") > 0) // Noncompliant
{
  // ...
}
if (Array.IndexOf(stringArray, color) > 0) // Noncompliant
{
  // ...
}

```

规范的例子：

```C#
List<string> strings = new List<string> ();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) > -1)
{
  // ...
}
if (name.IndexOf("ish") >= 0)
{
  // ...
}
if (name.Contains("ae"))
{
  // ...
}
if (Array.IndexOf(stringArray, color) >= 0)
{
  // ...
}
```

## 10.interface 实例不应转换为具体类型

需要从 interface 转换为具体类型表示抽象有问题，可能是缺少了 interface。代替强制转换为具体类型，应将缺少的方法添加到中 interface。否则存在运行时异常的风险。

不规范的例子：

```C#
public interface IMyInterface
{
  void DoStuff();
}

public class MyClass1 : IMyInterface
{
  public int Data { get { return new Random().Next(); } }

  public void DoStuff()
  {
    // TODO...
  }
}

public static class DowncastExampleProgram
{
  static void EntryPoint(IMyInterface interfaceRef)
  {
    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant
    int privateData = class1.Data;

    class1 = interfaceRef as MyClass1;  // Noncompliant
    if (class1 != null)
    {
      // ...
    }
  }
}

```

## 11.建议使用"nameof"

"nameof" should be used

因为在重构过程中参数名是可以更改的，所以不应该在字符串中逐字地拼写它们。相反，使用nameof()，输出的字符串一定是正确的。

Noncompliant Code Example

```C#
void DoSomething(int someParameter)
{
    if (someParameter < 0)
    {
        throw new ArgumentException("Bad argument", "someParameter");  // Noncompliant
    }
}
```

Compliant Solution

```C#
void DoSomething(int someParameter)
{
    if (someParameter < 0)
    {
        throw new ArgumentException("Bad argument", nameof(someParameter));
    }
}
```

## 12. 谨慎使用 out 和 ref 参数

"out" and "ref" parameters should not be used

不规范的例子：

```C#
public void GetReply(
         ref MyClass input, // Noncompliant
         out string reply)  // Noncompliant
{ ... }
```

规范的例子：

```C#
public string GetReply(MyClass input)
{ ... }

public bool TryGetReply(MyClass input, out string reply)
{ ... }

public ReplyData GetReply(MyClass input)
{ ... }

internal void GetReply(ref MyClass input, out string reply) // 非公开
{ ... }
```

## 13.重写时不应该加上 params

"params" should not be introduced on overrides

不规范的例子：

```C#
class Base
{
  public virtual void Method(int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(params int[] numbers) // Noncompliant, method can't be called with params syntax.
  {
    ...
  }
}

```

规范的例子：

```C#
class Base
{
  public virtual void Method(int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(int[] numbers)
  {
    ...
  }
}
```

## 14.switch 语句最好不要嵌套使用

"switch" statements should not be nested

嵌套 switch 结构很难理解，因为您很容易将内部 switch 的情况误认为属于外部语句。因此，应该避免使用嵌套的switch语句。

具体来说，应该以避免嵌套switch语句，但是如果不能，则考虑将内部switch移到另一个函数。

## 15. “switch/Select”语句应该包含“default/Case Else”子句


不规范的例子：

```C#
int foo = 42;
switch (foo) // Noncompliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
}
```

规范的例子：

```C#
int foo = 42;
switch (foo) // Compliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
  default:
    throw new InvalidOperationException("Unexpected value foo = " + foo);
}
```

## 16.正确使用 ValueTask

"ValueTask" should be consumed correctly

## 17.条件语句的单行应该用缩进表示

A conditionally executed single line should be denoted by indentation

不规范的例子：

```C#
if (condition)  // Noncompliant
DoTheThing();

DoTheOtherThing();
SomethingElseEntirely();

Foo();
```

规范的例子：

```C#
if (condition)
  DoTheThing();

DoTheOtherThing();
SomethingElseEntirely();
```

## 18.数组共异变量

Array covariance should not be used

数组共异变量的原则是，如果隐式或显式的引用转换存在于类型A到B之间，那么同样的转换也存在于类型A[]到B[]之间。

虽然这种数组转换对于在需要B[]的情况下传递A[]的实例非常有用，但是必须谨慎使用，因为将B的实例分配给A的数组会在运行时引发ArrayTypeMismatchException异常。

不规范的例子：

```C#
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used
    FillWithOranges(fruits);
  }

  // Just looking at the code doesn't reveal anything suspicious
  static void FillWithOranges(Fruit[] fruits)
  {
    for (int i = 0; i < fruits.Length; i++)
    {
      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException
    }
  }
}
```

规范的例子：

```C#
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Orange[] fruits = new Orange[1]; // Compliant
    FillWithOranges(fruits);
  }

  static void FillWithOranges(Orange[] fruits)
  {
    for (int i = 0; i < fruits.Length; i++)
    {
      fruits[i] = new Orange();
    }
  }
}
```

## 19.程序集应该具有版本信息

Assemblies should have version information

## 20.不应该隐藏基类方法

Base class methods should not be hidden

当派生类中的方法与基类中的方法具有相同的名称，但其签名仅根据弱派生类型(例如，对象与字符串)而有所不同时，结果是基方法被隐藏。

```C#
using System;

namespace MyLibrary
{
  class Foo
  {
    internal void SomeMethod(string s1, string s2) { }
  }

  class Bar : Foo
  {
    internal void SomeMethod(string s1, object o2) { }  // Noncompliant
  }
}
```

规范的例子：

```C#
using System;

namespace MyLibrary
{
  class Foo
  {
    internal void SomeMethod(string s1, string s2) { }
  }

  class Bar : Foo
  {
    internal void SomeOtherMethod(string s1, object o2) { }
  }
}
```

## 21.子类字段与父类字段不应仅在大小写上有所不同

Child class fields should not shadow parent class fields

在子类中有一个字段，其名称仅与父类字段的大小写不同，这肯定会引起混淆。这样的子类字段应该重新命名。

不规范的例子：

```C#
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  protected string plantingseason;  // Noncompliant
  // ...
}
```

规范的例子：

```C#
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  protected string whenToPlant;
  // ...
}
```

或者

```C#
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  // field removed; parent field will be used instead
  // ...
}
```

## 22.方法的复杂性不应过高

Cognitive Complexity of methods should not be too high

## 23.条件句应该新的行开始

Conditionals should start on new lines

当每个语句都有自己的行时，代码最清楚。尽管如此，将if及其结果then语句组合在同一行是一种常见的模式。然而,当一个如果被放置在同一行从前面然后关闭},否则如果部分,它是一个错误——其他失踪——或者邀请未来错误维护人员无法理解,这两个语句是无关的。

不规范的例子：

```C#
if (condition1) {
  // ...
} if (condition2) {  // Noncompliant
  //...
}
```

规范的例子：

```C#
if (condition1) {
  // ...
} else if (condition2) {
  //...
}
```

或者

```C#
if (condition1) {
  // ...
}

if (condition2) {
  //...
}
```

## 24.构造函数应该只调用不可覆盖的方法


